import { exec, execSync } from 'child_process';
import path from 'path';
import fs from 'fs';
import { v4 as uuidv4 } from 'uuid';

export const autoEditVideo = async ({
  script,
  audioUrl,
  imageUrl,
  music,
}: {
  script: string;
  audioUrl: string;
  imageUrl: string;
  music: string;
}): Promise<string> => {
  try {
    const outputDir = path.join(__dirname, '..', '..', 'public', 'output');
    const imagePath = path.join(__dirname, '..', '..', 'public', imageUrl);
    const audioPath = path.join(__dirname, '..', '..', 'public', audioUrl);
    const musicPath = path.join(__dirname, '..', '..', 'public', music);

    if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

    const subtitlePath = path.join(outputDir, `sub-${uuidv4()}.ass`);
    const videoPath = path.join(outputDir, `video-${uuidv4()}.mp4`);

    // 문장 나누기
    const lines = script.split('.').filter(line => line.trim() !== '');

    // 1️⃣ 전체 TTS 길이 측정
    const getAudioDuration = (filePath: string) => {
      const cmd = `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${filePath}"`;
      return parseFloat(execSync(cmd).toString().trim());
    };
    const totalDuration = getAudioDuration(audioPath);

    // 2️⃣ 문장별 시간 계산 (비율로 나누고 0.5초 추가)
    const lineDurations = lines.map(() => (totalDuration / lines.length) + 0.3);

    // 3️⃣ ASS 자막 생성
    // 동적 시간 계산을 위한 변수 초기화
    let currentTime = 0; // 현재 자막 시작 시간 (초 단위)
    
    // 초 단위를 ASS 자막 형식(H:MM:SS.cc)으로 변환하는 함수
    // ASS 자막은 시간을 H:MM:SS.cc 형식으로 요구 (시간:분:초.백분초)
    const formatTime = (seconds: number) => {
      const hrs = Math.floor(seconds / 3600);        // 시간 계산 (3600초 = 1시간)
      const mins = Math.floor((seconds % 3600) / 60); // 분 계산 (3600으로 나눈 나머지를 60으로 나눔)
      const secs = Math.floor(seconds % 60);          // 초 계산 (60으로 나눈 나머지)
      const centis = Math.floor((seconds % 1) * 100); // 백분초 계산 (소수점 이하를 100으로 곱함)
      return `${hrs}:${mins}:${secs}.${centis}`;      // H:MM:SS.cc 형식으로 반환
    };

    // 각 문장별로 자막 이벤트 생성
    // 동적 시간 맞춤 원리:
    // 1. 전체 TTS 길이를 문장 개수로 나누어 각 문장의 지속 시간 계산
    // 2. currentTime을 누적하여 각 자막의 시작/종료 시간을 순차적으로 배치
    // 3. 이전 자막이 끝나는 시점이 다음 자막의 시작 시점이 됨
    const events = lines.map((line, i) => {
      const start = formatTime(currentTime);                    // 현재 자막 시작 시간
      const end = formatTime(currentTime + lineDurations[i]);  // 현재 자막 종료 시간 (시작 + 지속시간)
      currentTime += lineDurations[i];                         // 다음 자막을 위해 시간 누적
      
      // ASS 자막 형식: Dialogue: Layer,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text
      // Layer: 0 (기본 레이어), Style: Default (기본 스타일), Text: 실제 자막 텍스트
      return `Dialogue: 0,${start},${end},Default,,0,0,0,,${line.trim()}`;
    }).join('\n');

    const assContent = `[Script Info]
; Script generated by autoEditVideo
Title: Generated Subtitles
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1080
PlayResY: 1920
WrapStyle: 0
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,NanumGothic,48,&H00FFFFFF,&H000000FF,&H00000000,&H64000000,0,0,0,0,100,100,0,0,1,2,2,2,30,30,60,0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
${events}
`;

    fs.writeFileSync(subtitlePath, assContent, { encoding: "utf8" });

    const subtitlePathNormalized = subtitlePath.replace(/\\/g, "/").replace(/:/g, "\\:");

    
    // 4️⃣ FFmpeg 명령어 (TTS 볼륨 높임, BGM 볼륨 낮춤)
    const cmd = `ffmpeg -y -loop 1 -i "${imagePath}" -i "${audioPath}" -i "${musicPath}" \
-filter_complex "[0:v]scale=1080:1920,setsar=1,ass='${subtitlePathNormalized}'[v]; \
[1:a]volume=1.2[a1]; \
[2:a]volume=0.3[a2]; \
[a1][a2]amix=inputs=2:duration=longest:dropout_transition=2[outa]" \
-map "[v]" -map "[outa]" \
-t ${totalDuration} -c:v libx264 -c:a aac -shortest "${videoPath}"`;

    console.log('FFmpeg 명령어:', cmd);

    return new Promise((resolve, reject) => {
      exec(cmd, (err, stdout, stderr) => {
        if (err) {
          console.error('FFmpeg err 오류:', err);
          console.error('FFmpeg stderr 오류:', stderr);
          reject(null);
        } else {
          console.log('영상 경로:', videoPath);
          resolve(`/output/${path.basename(videoPath)}`);
        }
      });
    });

  } catch (error) {
    console.error('영상 편집 실패:', error);
    return '';
  }
};
